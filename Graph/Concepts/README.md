# Important Graph Concepts to Understand

| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [DFS Of Directed Acylic Graph](https://www.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1) | DFS explores as far as possible along each branch before backtracking, allowing us to visit all the vertices in a connected component of the graph. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/1-dfs-in-dag.md) |
| [BFS Of Directed Acylic Graph](https://www.geeksforgeeks.org/problems/bfs-traversal-of-graph/1) | BFS explores the graph level by level, visiting all the vertices at the current level before moving on to the next level. It uses a queue to keep track of the vertices to be visited. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/2-bfs-in-dag.md) |
| [Detect Cycle in Directed Graph using DFS](https://www.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1) |  Perform DFS traversal and keep track of the vertices that are currently being visited in the recursion stack (Separate Stack). If we encounter a vertex that is already in the recursion stack, it means we have found a cycle | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/3-detect-cycle-in-directed-graph.md) |
| [Topological Sort using DFS](https://www.geeksforgeeks.org/problems/topological-sort/1) | To find the topological ordering is by using depth-first search (DFS) and storing the vertices in a stack in the order of their completion times | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/4-topological-sort-dfs.md) |
| [Kahns Algorithm (Topological Sort using BFS)](https://www.geeksforgeeks.org/problems/topological-sort/1) | involves calculating the in-degree of each vertex and iteratively removing vertices with in-degree 0 and their outgoing edges | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/5-topological-sort-bfs.md) |
| [Bipartite Graph using DFS](https://www.geeksforgeeks.org/problems/bipartite-graph/1) | Use depth-first search (DFS) to traverse the graph and assign colors to the vertices. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/6-bipartite-graph-using-dfs.md) |
| [Bipartite Graph using BFS](https://www.geeksforgeeks.org/problems/bipartite-graph/1) | Start by assigning one color to a vertex and then alternately assign different colors to its adjacent vertices. If at any point we find that two adjacent vertices have the same color, it means the graph is not bipartite. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/7-bipartite-graph-using-bfs.md)|
| [Disjoint Set Union](https://www.geeksforgeeks.org/problems/disjoint-set-union-find/1) | The find operation determines the parent or representative of a set, while the union operation merges two sets together. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/8-disjoint-set-union.md) |
| [Disjoint Set Union by Path Compression](https://www.geeksforgeeks.org/problems/disjoint-set-union-find/1) | The find operation determines the parent or representative of a set, while the union operation merges two sets together based on their ranks. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/9-disjoint-set-union-by-rank-path-compression.md) |
| [Dijkstras Algorithm](https://www.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1) | Maintain a priority queue of vertices based on their tentative distances from the source vertex. At each step, the vertex with the minimum tentative distance is selected, and its adjacent vertices are updated if a shorter path is found. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/10-dijkstras-alogrithm.md) |
| [Bellman Ford Algorithm](https://www.geeksforgeeks.org/problems/distance-from-the-source-bellman-ford-algorithm/1) | The Bellman-Ford algorithm is used to find the shortest paths from a single source vertex to all other vertices in a weighted graph, even if the graph contains negative edge weights. The algorithm works by relaxing edges repeatedly for V-1 iterations, where V is the number of vertices in the graph. After V-1 iterations, if there are still edges that can be relaxed, it indicates the presence of a negative cycle in the graph. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/11-bellman-ford.md) |
| [Flyod Warshal Algorithm](https://www.geeksforgeeks.org/problems/implementing-floyd-warshall2042/1) | The Floyd-Warshall algorithm is used to find the shortest distances between all pairs of vertices in a weighted graph. The algorithm works by considering all vertices as potential intermediate vertices and incrementally updating the shortest distances between pairs of vertices. It can handle negative edge weights but not negative cycles. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/12-floyd-warshal.md) |
| [Prims Algorithm](https://www.geeksforgeeks.org/problems/minimum-spanning-tree/1) | Start with an arbitrary vertex and greedily selects the minimum weight edge that connects a visited vertex to an unvisited vertex until all vertices are visited. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/13-prims-algorithm.md) |
| [Kruskal's Algorithm](https://www.geeksforgeeks.org/problems/minimum-spanning-tree/1) | Start by sorting all the edges in ascending order of their weights and then greedily selects the minimum weight edge that does not create a cycle until all vertices are connected. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/14-kruskals-algorithm.md) |
| [Kosaraju's Algorithm](https://www.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1) | Perform two depth-first search (DFS) traversals on the graph. The first DFS helps in finding the order of vertices based on their completion times, and the second DFS on the transposed graph helps in identifying the SCCs. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/15-kosarajus-algorithm.md) |
| [Euler Circuit and Path](https://www.geeksforgeeks.org/problems/euler-circuit-and-path/1) | To determine if a graph contains an Eulerian circuit or an Eulerian path, we can use the following properties:An Eulerian circuit exists if all vertices have an even degree.An Eulerian path exists if exactly two vertices have an odd degree. | [Solution](https://github.com/sharmahr/DSA/blob/main/Graph/Concepts/16-euler-circuit-and-path.md) |
