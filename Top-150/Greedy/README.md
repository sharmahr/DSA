# Greedy
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) | The intuition behind Kadane's algorithm is to maintain a variable that stores the maximum sum ending at the current position and another variable that keeps track of the overall maximum sum encountered so far. At each step, we decide whether to start a new subarray or continue the existing subarray based on whether including the current element increases the sum or not. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/01-maximum-strategy.md) |
| [Jump Game](https://leetcode.com/problems/jump-game/description/) | The intuition is to start from the first index and recursively explore all possible jumps from each index. If we can reach the last index from any intermediate index, we can reach the end of the array. We can use memoization to avoid redundant recursive calls and optimize the solution. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/02-jump-game.md) |
| [Jump Game 2](https://leetcode.com/problems/jump-game-ii/description/) | The intuition is to keep track of the farthest position we can reach from the current position and update it as we iterate through the array. We also need to keep track of the end of the current jump and increment the jump count whenever we reach the end of the current jump. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/03-jump-game-2.md) |
| [Gas Station](https://leetcode.com/problems/gas-station/description/) | The intuition is to keep track of the total gas and total cost as we traverse the stations. If the total cost is greater than the total gas, it means a complete tour is not possible. Otherwise, we can find the starting station by maintaining a running total of the gas minus the cost. Whenever the running total becomes negative, we reset it to zero and consider the next station as a potential starting point. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/04-gas-station.md) |
| [Hand of Straights](https://leetcode.com/problems/hand-of-straights/description/) | The intuition is to sort the hand and process the cards in ascending order. For each card, we check if we can form a group of the given size by checking the frequency of the consecutive cards in the hashmap. If any card is missing or has a frequency of zero, it means we cannot form a group, and the hand is not a valid arrangement. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/05-hand-of-straights.md) |
| [Merge Triplets to form Target Triplets](https://leetcode.com/problems/merge-triplets-to-form-target-triplet/) | The intuition is to iterate through each triplet and update a new triplet with the maximum values from the current triplet and the previously merged triplet, as long as each value is less than or equal to the corresponding value in the target triplet. If the merged triplet matches the target triplet at the end, it means we can merge the triplets to form the target triplet. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/06-merge-triplets-to-form-target-triplet.md) |
| [Partition Labels](https://leetcode.com/problems/partition-labels/description/) | The intuition is to find the last occurrence of each character in the string and use that information to determine the partition points. We can use a hashmap to store the last occurrence index of each character. Then, we iterate through the string and update the last occurrence index whenever we encounter a character. When we reach the last occurrence index of a character, we have found a partition point.
 | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/07-partition-labels.md) |
| [Valid Parenthesis](https://leetcode.com/problems/valid-parenthesis-string/) | The intuition is that for each character in the string, we update the minimum and maximum counts based on the character. If the maximum count becomes negative at any point, it means there are too many closing parentheses, and the string is invalid. If the minimum count becomes negative, we reset it to 0 since we can consider the asterisks as empty. At the end, if the minimum count is 0, it means all open parentheses are matched, and the string is valid. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Greedy/08-valid-parenthesis-string.md) |