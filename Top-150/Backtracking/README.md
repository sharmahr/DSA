# Backtracking
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [01-subsets](https://leetcode.com/problems/subsets/description/) | The intuition is to generate subsets by either including or excluding each element of the set. We can start with an empty subset and gradually build subsets by making decisions for each element. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/01-subsets.md) |
| [Combination Sum](https://leetcode.com/problems/combination-sum/) | The intuition is to generate combinations by making choices at each step, and backtrack when the sum exceeds the target or when a valid combination is found. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/02-combination-sum.md) |
| [Permutations](https://leetcode.com/problems/permutations/description/) | The intuition is to build permutations by making choices at each step, and backtrack when a complete permutation is formed or when an element has already been used. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/03-permutations.md) |
| [Subset 2](https://leetcode.com/problems/subsets-ii/description/) | The problem of generating all unique subsets of a given set that may contain duplicates can be solved using a recursive approach similar to generating subsets without duplicates. The key difference is that we need to handle duplicates to avoid generating duplicate subsets. Sorting the input array helps in identifying and skipping duplicates during the subset generation process. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/04-subsets-2.md) |
| [Combination Sum 2](https://leetcode.com/problems/combination-sum-ii/description/) | The problem of finding all unique combinations that sum up to a target, where each candidate can be used only once, can be solved using a backtracking approach similar to the combination sum problem. The key difference is that we need to handle duplicates and ensure that each candidate is used at most once in each combination. Sorting the input array helps in identifying and skipping duplicates during the backtracking process. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/05-combination-sum-2.md) |
| [Word Search](https://leetcode.com/problems/word-search/description/) | The intuition is to explore all possible paths in the grid by starting from each cell and recursively checking the neighboring cells to find a match for the given word. We can use a visited array to keep track of the cells that have been visited to avoid visiting the same cell multiple times. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/06-word-search.md) |
| [Palindromic Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/) | The intuition is to generate all possible substrings of the given string and check if each substring is a palindrome. If a substring is a palindrome, it can be added to the current partition, and the process can be repeated for the remaining part of the string. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/07-palindrome-partitioning.md) |
| [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/) | Row 3, Cell 2 | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/08-letter-combinations-of-a-phone-number.md) |
| [N Queens](https://leetcode.com/problems/n-queens/description/) | The intuition is to place queens on the chessboard row by row, and for each row, we try placing the queen in each column. We need to ensure that no two queens attack each other, i.e., no two queens share the same row, column, or diagonal. We can use boolean arrays to keep track of the columns and diagonals that are already occupied by queens. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/09-n-queens.md) |