# Advanced Graphs
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/description/) | To find the minimum cost to connect all points, we can use Prim's algorithm for minimum spanning tree (MST). We start with any point and gradually expand the tree by adding the point with the minimum cost edge that connects to the existing tree until all points are included. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/01-min-cost-to-connected-all-points.md) |
| [Network Delay Time](https://leetcode.com/problems/network-delay-time/) | To find the network delay time, we can use Dijkstra's algorithm to calculate the shortest distance from the starting node to all other nodes. The network delay time will be the maximum distance among all reachable nodes. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/02-network-delay-time.md) |
| [Cheapest Flights within K stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) | To find the cheapest price from the source city to the destination city with at most k stops, we can use the Bellman-Ford algorithm. This algorithm allows us to find the shortest path from a source vertex to all other vertices in a weighted graph, even with negative edge weights. In this case, we can modify the algorithm to limit the number of stops. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/03-cheapest-flights-within-k-stops.md) |
| [Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/) | To find the itinerary in lexical order, we can use a depth-first search (DFS) approach. We can represent the tickets as a graph, where each airport is a node, and each ticket is an edge. We can use a map to store the graph, with the source airport as the key and a priority queue of destination airports as the value. The priority queue ensures that the destinations are visited in lexical order. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/04-reconstruct-itinerary.md) |
| [Swim In rising Water](https://leetcode.com/problems/swim-in-rising-water/) | To find the minimum time required to swim from the top-left corner to the bottom-right corner, we can use Dijkstra's algorithm. We can treat each cell in the grid as a node in a graph, and the value of each cell represents the time required to swim through that cell. We can use a priority queue (min-heap) to always select the cell with the minimum time. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/05-swim-in-rising-water.md) |
| [Alien Dictionary](https://neetcode.io/problems/foreign-dictionary) | To find the order of characters in an alien language, we can use topological sorting. We can build a directed graph based on the lexicographic order of the words in the dictionary. Each character represents a node in the graph, and there is an edge from character `a` to character `b` if `a` comes before `b` in the lexicographic order. After building the graph, we can perform a topological sort to determine the order of the characters. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/06-alien-dictionary.md) |