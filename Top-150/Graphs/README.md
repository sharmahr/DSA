# Graphs
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Number of Islands](https://leetcode.com/problems/number-of-islands/) | We can traverse the grid and whenever we encounter a '1', we can perform DFS to explore the connected land cells and mark them as visited by changing them to '0'. Each DFS call will represent one island. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/) |
| [Max Area of Islands](https://leetcode.com/problems/max-area-of-island/description/) | We can traverse the grid and whenever we encounter a cell with value 1 (representing land), we perform DFS to explore the connected land cells and count the area of that island. We keep track of the maximum area encountered during the traversal. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/02-max-areal-of-islands.md) |
| [Clone Graph](https://leetcode.com/problems/clone-graph/description/) | We can use a depth-first search (DFS) approach along with a hash map to keep track of visited nodes. The hash map will store the mapping between the original node and its cloned counterpart. We can recursively clone each node and its neighbors while avoiding duplicate cloning by checking the hash map. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/03-clone-graph.md) |
| [Island And Treasure](https://neetcode.io/problems/islands-and-treasure) | To find the number of steps required to reach the nearest treasure chest for each land cell, we can perform a multi-source breadth-first search (BFS) starting from all the treasure chests. By using BFS, we can ensure that each land cell is visited in the shortest path from the nearest treasure chest. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/04-wall-and-gates.md) |
| [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/) |  We can use a breadth-first search (BFS) approach. We start with the initially rotten oranges and spread the rot to their adjacent fresh oranges in each minute. We continue this process until all fresh oranges have rotted or there are no more rotten oranges to spread the rot. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/05-rotting-oranges.md) |
| [Pacific Atlantic Waterflow](https://leetcode.com/problems/pacific-atlantic-water-flow/) | We can perform depth-first search (DFS) from the boundary cells of the matrix. We start the DFS from the top and left sides for the Pacific ocean and from the bottom and right sides for the Atlantic ocean. During the DFS, we mark the cells that can reach the respective ocean. Finally, we find the cells that are marked as reachable for both oceans. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/06-pacific-atlantic-water-flow.md) |
| [Surrounded Regions](https://leetcode.com/problems/surrounded-regions/) | The idea is to identify the 'O' cells that are connected to the border cells and mark them as a special character ('*') to indicate that they should not be flipped to 'X'. After the DFS traversal, we iterate through the board and flip the remaining 'O' cells to 'X' and the '*' cells back to 'O'. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/07-surrounded-regions.md) |
| [Course Schedule](https://leetcode.com/problems/course-schedule/) | To determine if it is possible to finish all courses, we need to check if there are any cycles in the dependency graph. If there are no cycles, it means that all courses can be completed. We can use depth-first search (DFS) to detect cycles in the graph. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/08-course-schedule.md) |
| [Course Schedule 2](https://leetcode.com/problems/course-schedule-ii/) | To find a valid course schedule, we can use topological sorting. If there is a cycle in the dependency graph, it means that there is no valid course schedule. We can perform a depth-first search (DFS) on the graph and check for cycles. If no cycles are detected, we can generate a valid course schedule by adding the courses to a stack in the order of completion. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/09-course-schedule-2.md) |
| [Graph Valid Tree](https://neetcode.io/problems/valid-tree) | To determine if a given graph is a valid tree, we need to check two conditions:The graph must contain exactly n - 1 edges, where n is the number of nodes.The graph must be fully connected, meaning there is a path between any two nodes, and there are no cycles.We can use depth-first search (DFS) to traverse the graph and check for connectivity and cycles. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/10-graph-valid-tree.md) |
| [Number of Connected Components](https://neetcode.io/problems/count-connected-components) | To count the number of connected components in an undirected graph, we can perform depth-first search (DFS) on each unvisited node. Each DFS traversal will explore a single connected component, and the total number of DFS traversals will give us the count of connected components. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/11-number-of-connected-components-in-an-undirected-graph.md) |
| [Redundant Components](https://leetcode.com/problems/redundant-connection/description/) | By iterating through the edges and performing union operations, we can detect the edge that forms a cycle in the graph. The last edge that causes a cycle is the redundant connection. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/12-redundant-components.md) |
| [Word Ladder](https://leetcode.com/problems/word-ladder/description/) | we can use a breadth-first search (BFS) approach. We can treat each word as a node in a graph, and an edge exists between two words if they differ by exactly one letter. By performing BFS starting from `beginWord`, we can find the shortest path to reach `endWord`. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/13-word-ladder.md) |