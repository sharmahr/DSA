# Linked List
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Reverse a Linked List](https://leetcode.com/problems/reverse-linked-list/) | The intuition is to iteratively update the next pointers of each node to point to the previous node, effectively reversing the direction of the list. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/1-reverse-linked-list.md) |
| [Merge Two Sorted List](https://leetcode.com/problems/merge-two-sorted-lists/description/) | Compare the values of the nodes in the two input lists and add the smaller value node to the new list, while moving the pointer in the corresponding input list forward. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/2-merge-two-sorted-list.md) |
| [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/) | The idea is to use two pointers, one moving twice as fast as the other. If there is a cycle, the two pointers will eventually meet. If there is no cycle, the faster pointer will reach the end of the list first. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/3-linked-list-cycle.md) |
| [Reorder List](https://leetcode.com/problems/reorder-list/) | Split the list into two halves, reverse the second half, and then merge the two halves by interleaving the nodes. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/4-reorder-list.md) |
| [Remove Nth Node from the End](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/) | The intuition is to use two pointers, `first` and `second`, where `second` is initially ahead of `first` by `n` nodes. Then, move both pointers at the same pace until `second` reaches the end of the list. At this point, `first` will be pointing to the (n+1)th node from the end, and we can remove the next node (the nth node from the end). | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/5-remove-nth-node-from-end-of-list.md) |
| [Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/) | The intuition is to use a dictionary (HashMap) to map the original nodes to their corresponding copied nodes. We can then iterate through the original list, create copies of the nodes, and update the `next` and `random` pointers of the copied nodes based on the original nodes and the dictionary. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/6-copy-list-with-random-pointer.md) |
| [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description/) | The intuition is to perform digit-wise addition, similar to how we add numbers on paper, and propagate the carry to the next digit. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/7-add-two-numbers.md) |
| [Find the duplicate number](https://leetcode.com/problems/find-the-duplicate-number/description/) | The intuition is to use the concept of linked lists to treat the array as a linked list with nodes pointing to the indices represented by their values. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/8-find-the-duplicate-number.md) |
| [LRU Cache](https://leetcode.com/problems/lru-cache/) | The intuition is to use a combination of a hash map (or dictionary) and a doubly-linked list to efficiently track the key-value pairs and their access order. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/9-lru-cache.md) |
| [Merge K sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/) | We can use a min-heap to efficiently find the node with the smallest value among all the linked lists and add it to the merged list. This way, we can merge all the linked lists in a single pass. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/10-merge-k-sorted-list.md) |
| [Reverse Nodes in K groups](https://leetcode.com/problems/reverse-nodes-in-k-group/description/) | The intuition is to use a recursive approach to reverse the first `k` nodes of the linked list, and then move to the next group of `k` nodes and repeat the process. We can keep track of the next group's starting node by maintaining a reference to the node right after the current group. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/11-reverse-nodes-in-k-group.md) |