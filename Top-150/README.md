# Arrays And Hashing
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/description/) | Use the input array itself as a hash table to keep track of the elements we have encountered so far. By negating the value at the index corresponding to each element, we can mark it as visited. If we encounter a negative value at an index, it means we have already visited that element before, indicating a duplicate. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/1-contains-duplicate.md) |
| [Valid Anagram](https://leetcode.com/problems/valid-anagram/description/) | Count the frequency of each character in both strings and compare them or sort the strings and compare. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/2-valid-anagram.md) |
| [Two Sum](https://leetcode.com/problems/two-sum/) | Use a hashmap to store the elements of the array along with their indices | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/3-two-sum.md) |
| [Group Anagrams](https://leetcode.com/problems/group-anagrams/) | Use a hashmap where the key is a sorted version of each word, and the value is a list of words that are anagrams of each other | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/4-group-anagrams.md) |
| [Top K frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) | use a hash map to count the frequency of each element and then use a priority queue (min-heap) to keep track of the top k frequent elements. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/5-top-k-frequent-elements.md) |
| [Encode and Decode Strings](https://neetcode.io/problems/string-encode-and-decode) | Use a delimiter to separate the individual strings and include the length of each string before the delimiter to facilitate the decoding process. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/6-encode-decode-strings.md) |
| [Product of Array and Sef](https://leetcode.com/problems/product-of-array-except-self/description/) | Calculate the product of all the elements to the left of each index and the product of all the elements to the right of each index, and then multiply these two values to get the desired result. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/7-product-of-array-except-self.md) |
| [Valid Sudodu](https://leetcode.com/problems/valid-sudoku/description/) | Check the validity of each row, column, and 3x3 block separately. We can use a set to keep track of the numbers encountered in each row, column, and block. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/8-valid-sudoku.md) |
| [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/description/) | Use a hash set to store all the numbers in the array and then iterate through the set to find the longest consecutive sequence | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Arrays-And-Hashing/9-longest-consecutive-sequence.md) |



# Two Pointers
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Valid Palidrome](https://leetcode.com/problems/valid-palindrome/description/) | Use two pointers, one starting from the beginning and the other from the end of the string, and move them inwards while skipping non-alphanumeric characters. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Two-Pointers/1-valid-palindrome.md) |
| [Two Sum Input Array is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | Use the two-pointer approach, where we start with two pointers, one at the beginning and one at the end of the array, and move them based on the sum of the elements they point to. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Two-Pointers/2-two-sum-input-array-is-sorted.md) |
| [3Sum](https://leetcode.com/problems/3sum/description/) | Extend the two-pointer approach used in the two-sum problem to solve this problem. We can first sort the array, and then fix one element at a time. For each fixed element, we can use the two-pointer technique to find the other two elements that sum up to the negative of the fixed element. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Two-Pointers/3-3sum.md) |
| [Container with Most Water](https://leetcode.com/problems/container-with-most-water/description/) | Use two pointers, one at the beginning and one at the end of the array, and move them inwards to find the maximum area. The area is determined by the smaller of the two heights and the distance between the two lines. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Two-Pointers/4-container-with-most-water.md) |
| [Rainwater Trapping](https://leetcode.com/problems/trapping-rain-water/description/) | Use two pointers, one starting from the left and the other from the right, and keep track of the maximum height seen from both sides. The amount of water trapped at any point is determined by the minimum of the maximum heights on both sides and the current height. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Two-Pointers/5-trapping-rain-water.md) |


# Sliding Window
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Best time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/) | Keep track of the minimum price seen so far and the maximum profit that can be made by selling at the current price. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Sliding-Window/1-best-time-to-buy-sell-stock.md) |
| [Longest Substring without repeating characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/) | Use a sliding window technique, where we maintain a set of characters seen so far in the current substring, and expand or shrink the window as needed to ensure that there are no repeating characters. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Sliding-Window/2-longest-substring-without-repeating-characters.md) |
| [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/description/) | Use a sliding window technique, where we keep track of the maximum frequency of any character in the current window and the number of characters that need to be replaced to make the substring valid.| [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Sliding-Window/3-longest-repeating-character-replacement.md) |
| [Permutation in string](https://leetcode.com/problems/permutation-in-string/) | Use a sliding window technique and compare the frequency of characters in the window with the frequency of characters in s1. If the frequencies match, then the window contains a permutation of s1. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Sliding-Window/4-permutation-of-string.md) |
| [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description/) | Use a sliding window technique along with two frequency maps to keep track of the characters in `t` and the characters in the current window. We can slide the window and update the frequency maps accordingly to find the minimum window that satisfies the condition. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Sliding-Window/5-minimum-window-substring.md) |
| [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/description/) | Use a deque (double-ended queue) to store the indices of the elements in the current window. By maintaining the deque in a way that the front element is always the maximum value in the current window, we can efficiently find the maximum value for each window. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Sliding-Window/6-sliding-window-maximum.md) |


# Stack
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Valid Parenthesis](https://leetcode.com/problems/valid-parentheses/description/) | Use a stack data structure to keep track of the opening parentheses encountered in the string. When we come across a closing parenthesis, we check if it matches the last opening parenthesis in the stack. If it doesn't match, or if the stack is empty (meaning there are more closing parentheses than opening ones), then the string is invalid. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Stack/1-valid-parenthesis.md) |
| [Min Stack](https://leetcode.com/problems/min-stack/) | Use a stack to store the elements and maintain a variable `min` to keep track of the minimum element at any given time. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Stack/2-min-stack.md) |
| [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/description/) | Use a stack to evaluate the expression by pushing operands onto the stack and performing operations when an operator is encountered, using the operands from the top of the stack. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Stack/3-evaluate-reverse-polish-notation.md) |
| [Generate Parenthesis](https://leetcode.com/problems/generate-parentheses/description/) | The key idea is to ensure that at any point in the recursion, the number of closing parentheses does not exceed the number of opening parentheses. This property ensures that the generated combinations are well-formed. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Stack/4-generate-parentheses.md) |
| [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/description/) | Use a stack to keep track of the indices of the temperatures that are waiting for a warmer temperature. We can iterate through the temperatures in reverse order and update the answer for the indices in the stack whenever we encounter a warmer temperature. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Stack/5-daily-temperatures.md) |
| [Car Fleet](https://leetcode.com/problems/car-fleet/description/) | The problem is to determine the number of car fleets that will arrive at the destination, given the positions and speeds of the cars. The key observation is that if a car catches up to another car or fleet, it will slow down to match their speed. This means that cars or fleets with the same time to reach the destination will form a single fleet. We can calculate the time it takes for each car to reach the destination and sort them in descending order. Then, we can iterate through the sorted times and group cars with the same time into a fleet. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Stack/6-car-fleet.md) |
| [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/description/) | Use a stack to keep track of the indices of the bars that are part of the potential largest rectangle. We can iterate through the heights and update the area whenever we encounter a bar that ends a potential largest rectangle. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Stack/7-largest-rectangle-in-histogram.md) |


# Binary Search
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Binary Search](https://leetcode.com/problems/binary-search/description/) | The intuition is to repeatedly divide the search interval in half by comparing the middle element with the target value. If the middle element is equal to the target, we have found the solution. If the target is greater than the middle element, we search in the right half of the interval. Otherwise, we search in the left half of the interval. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Binary-Search/1-binary-search.md) |
| [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/description/) | The intuition is to treat the 2D matrix as a single sorted array and perform binary search on it. By flattening the matrix into a 1D array, we can leverage the existing binary search algorithm for sorted arrays or you can perform binary search without flattening the matrix just use the correct values of right and left. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Binary-Search/2-search-a-2d-matrix.md) |
| [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/) | We can start with a minimum possible speed of 1 banana per hour and a maximum possible speed equal to the maximum pile size. Then, we can perform a binary search on the range of possible speeds and check if the current speed allows Koko to eat all the bananas within the given hour constraint. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Binary-Search/3-koko-eating-bananas.md) |
| [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/) | Idea is to find the pivot point where the value transitions from a larger value to a smaller value. This pivot point is the minimum value in the rotated sorted array. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Binary-Search/4-find-minimum-in-rotated-sorted-array.md) |
| [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/) | Identify which half of the array is sorted and determine if the target element lies within that sorted half. By comparing the middle element with the target and the endpoints of the current search range, we can recursively narrow down the search space until the target is found or the search range is exhausted. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Binary-Search/5-search-in-rotated-sorted-array.md) |
| [Time Based Key Value Store](https://leetcode.com/problems/time-based-key-value-store/description/) | The intuition is to use a hash map to store the key-value pairs, where each key maps to a list of values along with their corresponding timestamps. To retrieve the value for a given key and timestamp, we can perform a binary search on the list of values to find the value with the highest timestamp less than or equal to the given timestamp. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Binary-Search/6-time-based-key-value-store.md) |
| [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | Perform a binary search on the smaller array to find the partition point that divides both arrays into left and right halves such that the elements in the left half are smaller than or equal to the elements in the right half. Once we find the correct partition, we can determine the median based on the maximum element in the left half and the minimum element in the right half. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Binary-Search/7-median-of-two-sorted-arrays.md) |


# Linked List
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Reverse a Linked List](https://leetcode.com/problems/reverse-linked-list/) | The intuition is to iteratively update the next pointers of each node to point to the previous node, effectively reversing the direction of the list. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/1-reverse-linked-list.md) |
| [Merge Two Sorted List](https://leetcode.com/problems/merge-two-sorted-lists/description/) | Compare the values of the nodes in the two input lists and add the smaller value node to the new list, while moving the pointer in the corresponding input list forward. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/2-merge-two-sorted-list.md) |
| [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/) | The idea is to use two pointers, one moving twice as fast as the other. If there is a cycle, the two pointers will eventually meet. If there is no cycle, the faster pointer will reach the end of the list first. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/3-linked-list-cycle.md) |
| [Reorder List](https://leetcode.com/problems/reorder-list/) | Split the list into two halves, reverse the second half, and then merge the two halves by interleaving the nodes. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/4-reorder-list.md) |
| [Remove Nth Node from the End](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/) | The intuition is to use two pointers, `first` and `second`, where `second` is initially ahead of `first` by `n` nodes. Then, move both pointers at the same pace until `second` reaches the end of the list. At this point, `first` will be pointing to the (n+1)th node from the end, and we can remove the next node (the nth node from the end). | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/5-remove-nth-node-from-end-of-list.md) |
| [Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/) | The intuition is to use a dictionary (HashMap) to map the original nodes to their corresponding copied nodes. We can then iterate through the original list, create copies of the nodes, and update the `next` and `random` pointers of the copied nodes based on the original nodes and the dictionary. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/6-copy-list-with-random-pointer.md) |
| [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description/) | The intuition is to perform digit-wise addition, similar to how we add numbers on paper, and propagate the carry to the next digit. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/7-add-two-numbers.md) |
| [Find the duplicate number](https://leetcode.com/problems/find-the-duplicate-number/description/) | The intuition is to use the concept of linked lists to treat the array as a linked list with nodes pointing to the indices represented by their values. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/8-find-the-duplicate-number.md) |
| [LRU Cache](https://leetcode.com/problems/lru-cache/) | The intuition is to use a combination of a hash map (or dictionary) and a doubly-linked list to efficiently track the key-value pairs and their access order. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/9-lru-cache.md) |
| [Merge K sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/) | We can use a min-heap to efficiently find the node with the smallest value among all the linked lists and add it to the merged list. This way, we can merge all the linked lists in a single pass. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/10-merge-k-sorted-list.md) |
| [Reverse Nodes in K groups](https://leetcode.com/problems/reverse-nodes-in-k-group/description/) | The intuition is to use a recursive approach to reverse the first `k` nodes of the linked list, and then move to the next group of `k` nodes and repeat the process. We can keep track of the next group's starting node by maintaining a reference to the node right after the current group. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Linked-List/11-reverse-nodes-in-k-group.md) |


# Trees
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/description/) | Perform a level-order traversal of the tree using a queue and swap the left and right child of each node as we visit it. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/01-invert-binary-tree.md) |
| [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | The maximum depth of a tree is the maximum depth of its left subtree or its right subtree, plus one (to account for the root node). We can recursively traverse the tree, calculate the maximum depth of the left and right subtrees, and return the maximum of the two depths plus one. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/02-maximum-depth-of-binary-tree.md) |
| [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/description/) | To find the diameter of a binary tree, consider three cases: the diameter passing through the root (sum of left and right subtree heights), or the diameter being entirely within the left or right subtree. Use recursion to calculate the maximum diameter among these cases. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/03-diameter-of-binary-tree.md) |
| [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/description/) | Calculate the heights of the left and right subtrees at each node and check if their difference is within the allowed range. If at any point the difference exceeds 1, the tree is not balanced. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/04-balanced-binary-tree.md) |
| [Same Tree](https://leetcode.com/problems/same-tree/description/) | Recursively compare the nodes and their left and right subtrees. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/05-same-tree.md) |
| [Subtree of another Tree](https://leetcode.com/problems/subtree-of-another-tree/description/) | We can recursively compare each node of the main tree with the root of the subtree. If we find a node in the main tree that is the same as the root of the subtree, we can then compare the entire subtree starting from that node. If any such comparison returns true, then the subtree exists within the main tree. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/06-subtree-of-another-tree.md) |
| [Lowest Common Ancestor of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/) | The LCA is the node where the two nodes p and q diverge in the tree. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/07-lowest-common-ancestor-of-bst.md ) |
| [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/) | Process the nodes level by level, starting from the root. At each level, we enqueue the nodes from left to right and process them in the order they were enqueued. This ensures that we visit the nodes in level order. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/08-binary-tree-level-order-traversal.md) |
| [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/description/) | To find the right side view of a binary tree, we can perform a level order traversal (breadth-first search) and keep track of the rightmost node at each level. The rightmost node at each level will be the one visible from the right side. We can use a queue to perform the level order traversal and add the last node at each level to the result list. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/09-binary-tree-right-side-view.md) |
| [Count Of Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/) | To count the number of good nodes in a binary tree, we can perform a depth-first search (DFS) traversal and keep track of the maximum value encountered so far along each path. If the current node's value is greater than or equal to the maximum value seen so far, it is considered a good node. We can recursively traverse the tree and update the maximum value at each step. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/10-count-good-nodes-in-binary-tree.md) |
| [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/description/) | Keep track of the valid range for each node based on its ancestors. The valid range for a node is determined by the minimum and maximum values allowed for it to satisfy the BST property. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/11-validate-binary-search-tree.md) |
| [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/) | By performing an in-order traversal and storing the elements in a list, we can easily retrieve the kth smallest element by accessing the element at index k-1 in the list. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/12-kth-smallest-element-in-bst.md) |
| [Construct Binary Tree from Inorder and Preorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/) | Create a map of the using the inorder array <val, index>, and then build tree recursively from the preorder by passing the start and end.| [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/13-construct-binary-tree-from-inorder-and-preorder-traversal.md) |
| [Maximum Path Sum in a Binary Tree](https://leetcode.com/problems/binary-tree-maximum-path-sum/) | Row 3, Cell 2 | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/14-binary-tree-maximum-path-sum.md) |
| [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/) | Use any of the traversals --> preorder, postorder ( along with a delimiter) or level order traversal | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/15-serialize-deserialize-binary-tree.md) |



# Heap
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Kth Largest Element in a stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/) | The min-heap will store the k largest elements encountered so far. Whenever a new element is added, if it is larger than the smallest element in the min-heap (i.e., the root), we remove the root and insert the new element into the min-heap. This way, the root of the min-heap will always be the kth largest element. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Heap/1-kth-largest-element-in-a-stream.md) |
| [Last Stone Weight](https://leetcode.com/problems/last-stone-weight/description/) | We can add all the stones to the max-heap and then repeatedly remove the two heaviest stones, smash them together, and add the resulting stone (if any) back to the heap until there is at most one stone left. The weight of the remaining stone (if any) will be the result. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Heap/2-last-stone-weight.md) |
| [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/description/) | To find the k closest points to the origin, we can calculate the distance of each point from the origin and use a max-heap to store the k closest points. The max-heap will store the points based on their distances from the origin in descending order. If a point has a smaller distance than the top element of the max-heap, we remove the top element and add the new point to the heap. This way, the max-heap will always maintain the k closest points. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Heap/3-k-closest-points-to-origin.md) |
| [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | We can maintain a min-heap of size k, where the heap stores the k largest elements encountered so far. Whenever we encounter a new element, if it is larger than the smallest element in the min-heap (i.e., the root), we remove the root and insert the new element into the min-heap. This way, the root of the min-heap will always be the kth largest element. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Heap/4-kth-largest-element-in-a-array.md) |
| [Task Scheduler](https://leetcode.com/problems/task-scheduler/) | The idea is to schedule the tasks with the highest frequency first and distribute them evenly with cooling intervals in between. We can determine the minimum number of intervals required based on the maximum frequency of the tasks and the number of tasks with the maximum frequency. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Heap/5-task-scheduler.md) |
| [Design Twitter](https://leetcode.com/problems/design-twitter/) | To design a simplified version of Twitter, we need to store the tweets posted by each user and keep track of the users that each user follows. We can use a map to store the tweets of each user, where the key is the user ID and the value is a list of tweets. We can also use another map to store the followings of each user, where the key is the user ID and the value is a set of user IDs that the user follows.To retrieve the news feed for a user, we need to get the most recent tweets from the user's own tweets and the tweets of the users they follow. We can use a priority queue to efficiently retrieve the top 10 most recent tweets. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Heap/6-design-twitter.md) |
| [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/description/) | By maintaining a max-heap for the lower half of the numbers and a min-heap for the upper half of the numbers, we can efficiently access the middle element(s) to calculate the median. The key intuition is to balance the heaps so that the size difference between them is at most 1, and the top element of the max-heap is smaller than or equal to the top element of the min-heap. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Heap/7-find-median-from-data-stream.md) |

# Backtracking
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [01-subsets](https://leetcode.com/problems/subsets/description/) | The intuition is to generate subsets by either including or excluding each element of the set. We can start with an empty subset and gradually build subsets by making decisions for each element. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/01-subsets.md) |
| [Combination Sum](https://leetcode.com/problems/combination-sum/) | The intuition is to generate combinations by making choices at each step, and backtrack when the sum exceeds the target or when a valid combination is found. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/02-combination-sum.md) |
| [Permutations](https://leetcode.com/problems/permutations/description/) | The intuition is to build permutations by making choices at each step, and backtrack when a complete permutation is formed or when an element has already been used. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/03-permutations.md) |
| [Subset 2](https://leetcode.com/problems/subsets-ii/description/) | The problem of generating all unique subsets of a given set that may contain duplicates can be solved using a recursive approach similar to generating subsets without duplicates. The key difference is that we need to handle duplicates to avoid generating duplicate subsets. Sorting the input array helps in identifying and skipping duplicates during the subset generation process. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/04-subsets-2.md) |
| [Combination Sum 2](https://leetcode.com/problems/combination-sum-ii/description/) | The problem of finding all unique combinations that sum up to a target, where each candidate can be used only once, can be solved using a backtracking approach similar to the combination sum problem. The key difference is that we need to handle duplicates and ensure that each candidate is used at most once in each combination. Sorting the input array helps in identifying and skipping duplicates during the backtracking process. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/05-combination-sum-2.md) |
| [Word Search](https://leetcode.com/problems/word-search/description/) | The intuition is to explore all possible paths in the grid by starting from each cell and recursively checking the neighboring cells to find a match for the given word. We can use a visited array to keep track of the cells that have been visited to avoid visiting the same cell multiple times. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/06-word-search.md) |
| [Palindromic Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/) | The intuition is to generate all possible substrings of the given string and check if each substring is a palindrome. If a substring is a palindrome, it can be added to the current partition, and the process can be repeated for the remaining part of the string. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/07-palindrome-partitioning.md) |
| [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/) | Row 3, Cell 2 | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/08-letter-combinations-of-a-phone-number.md) |
| [N Queens](https://leetcode.com/problems/n-queens/description/) | The intuition is to place queens on the chessboard row by row, and for each row, we try placing the queen in each column. We need to ensure that no two queens attack each other, i.e., no two queens share the same row, column, or diagonal. We can use boolean arrays to keep track of the columns and diagonals that are already occupied by queens. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Backtracking/09-n-queens.md) |

# Graphs
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Number of Islands](https://leetcode.com/problems/number-of-islands/) | We can traverse the grid and whenever we encounter a '1', we can perform DFS to explore the connected land cells and mark them as visited by changing them to '0'. Each DFS call will represent one island. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/) |
| [Max Area of Islands](https://leetcode.com/problems/max-area-of-island/description/) | We can traverse the grid and whenever we encounter a cell with value 1 (representing land), we perform DFS to explore the connected land cells and count the area of that island. We keep track of the maximum area encountered during the traversal. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/02-max-areal-of-islands.md) |
| [Clone Graph](https://leetcode.com/problems/clone-graph/description/) | We can use a depth-first search (DFS) approach along with a hash map to keep track of visited nodes. The hash map will store the mapping between the original node and its cloned counterpart. We can recursively clone each node and its neighbors while avoiding duplicate cloning by checking the hash map. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/03-clone-graph.md) |
| [Island And Treasure](https://neetcode.io/problems/islands-and-treasure) | To find the number of steps required to reach the nearest treasure chest for each land cell, we can perform a multi-source breadth-first search (BFS) starting from all the treasure chests. By using BFS, we can ensure that each land cell is visited in the shortest path from the nearest treasure chest. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/04-wall-and-gates.md) |
| [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/) |  We can use a breadth-first search (BFS) approach. We start with the initially rotten oranges and spread the rot to their adjacent fresh oranges in each minute. We continue this process until all fresh oranges have rotted or there are no more rotten oranges to spread the rot. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/05-rotting-oranges.md) |
| [Pacific Atlantic Waterflow](https://leetcode.com/problems/pacific-atlantic-water-flow/) | We can perform depth-first search (DFS) from the boundary cells of the matrix. We start the DFS from the top and left sides for the Pacific ocean and from the bottom and right sides for the Atlantic ocean. During the DFS, we mark the cells that can reach the respective ocean. Finally, we find the cells that are marked as reachable for both oceans. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/06-pacific-atlantic-water-flow.md) |
| [Surrounded Regions](https://leetcode.com/problems/surrounded-regions/) | The idea is to identify the 'O' cells that are connected to the border cells and mark them as a special character ('*') to indicate that they should not be flipped to 'X'. After the DFS traversal, we iterate through the board and flip the remaining 'O' cells to 'X' and the '*' cells back to 'O'. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/07-surrounded-regions.md) |
| [Course Schedule](https://leetcode.com/problems/course-schedule/) | To determine if it is possible to finish all courses, we need to check if there are any cycles in the dependency graph. If there are no cycles, it means that all courses can be completed. We can use depth-first search (DFS) to detect cycles in the graph. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/08-course-schedule.md) |
| [Course Schedule 2](https://leetcode.com/problems/course-schedule-ii/) | To find a valid course schedule, we can use topological sorting. If there is a cycle in the dependency graph, it means that there is no valid course schedule. We can perform a depth-first search (DFS) on the graph and check for cycles. If no cycles are detected, we can generate a valid course schedule by adding the courses to a stack in the order of completion. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/09-course-schedule-2.md) |
| [Graph Valid Tree](https://neetcode.io/problems/valid-tree) | To determine if a given graph is a valid tree, we need to check two conditions:The graph must contain exactly n - 1 edges, where n is the number of nodes.The graph must be fully connected, meaning there is a path between any two nodes, and there are no cycles.We can use depth-first search (DFS) to traverse the graph and check for connectivity and cycles. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/10-graph-valid-tree.md) |
| [Number of Connected Components](https://neetcode.io/problems/count-connected-components) | To count the number of connected components in an undirected graph, we can perform depth-first search (DFS) on each unvisited node. Each DFS traversal will explore a single connected component, and the total number of DFS traversals will give us the count of connected components. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/11-number-of-connected-components-in-an-undirected-graph.md) |
| [Redundant Components](https://leetcode.com/problems/redundant-connection/description/) | By iterating through the edges and performing union operations, we can detect the edge that forms a cycle in the graph. The last edge that causes a cycle is the redundant connection. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/12-redundant-components.md) |
| [Word Ladder](https://leetcode.com/problems/word-ladder/description/) | we can use a breadth-first search (BFS) approach. We can treat each word as a node in a graph, and an edge exists between two words if they differ by exactly one letter. By performing BFS starting from `beginWord`, we can find the shortest path to reach `endWord`. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Graphs/13-word-ladder.md) |


# Advanced Graphs
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/description/) | To find the minimum cost to connect all points, we can use Prim's algorithm for minimum spanning tree (MST). We start with any point and gradually expand the tree by adding the point with the minimum cost edge that connects to the existing tree until all points are included. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/01-min-cost-to-connected-all-points.md) |
| [Network Delay Time](https://leetcode.com/problems/network-delay-time/) | To find the network delay time, we can use Dijkstra's algorithm to calculate the shortest distance from the starting node to all other nodes. The network delay time will be the maximum distance among all reachable nodes. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/02-network-delay-time.md) |
| [Cheapest Flights within K stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) | To find the cheapest price from the source city to the destination city with at most k stops, we can use the Bellman-Ford algorithm. This algorithm allows us to find the shortest path from a source vertex to all other vertices in a weighted graph, even with negative edge weights. In this case, we can modify the algorithm to limit the number of stops. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/03-cheapest-flights-within-k-stops.md) |
| [Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/) | To find the itinerary in lexical order, we can use a depth-first search (DFS) approach. We can represent the tickets as a graph, where each airport is a node, and each ticket is an edge. We can use a map to store the graph, with the source airport as the key and a priority queue of destination airports as the value. The priority queue ensures that the destinations are visited in lexical order. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/04-reconstruct-itinerary.md) |
| [Swim In rising Water](https://leetcode.com/problems/swim-in-rising-water/) | To find the minimum time required to swim from the top-left corner to the bottom-right corner, we can use Dijkstra's algorithm. We can treat each cell in the grid as a node in a graph, and the value of each cell represents the time required to swim through that cell. We can use a priority queue (min-heap) to always select the cell with the minimum time. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/05-swim-in-rising-water.md) |
| [Alien Dictionary](https://neetcode.io/problems/foreign-dictionary) | To find the order of characters in an alien language, we can use topological sorting. We can build a directed graph based on the lexicographic order of the words in the dictionary. Each character represents a node in the graph, and there is an edge from character `a` to character `b` if `a` comes before `b` in the lexicographic order. After building the graph, we can perform a topological sort to determine the order of the characters. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Advanced-Graphs/06-alien-dictionary.md) |


# 1-D DP
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/) | We can observe that to reach the nth step, we can either climb 1 step from the (n-1)th step or 2 steps from the (n-2)th step. This forms a recursive pattern similar to the Fibonacci sequence. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/01-climbing-stairs.md) |
| [Minimum Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/description/) | At each step, we have two choices: either take one step or take two steps. We need to choose the option that minimizes the total cost. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/02-min-cost-to-climb-stairs.md) |
| [House Robber](https://leetcode.com/problems/house-robber/) | At each house, we have two options: either rob the current house and add its amount to the maximum amount robbed from two houses before, or skip the current house and consider the maximum amount robbed from the previous house. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/03-house-robber.md) |
| [House Robber 2](https://leetcode.com/problems/house-robber-ii/) | The problem of robbing houses in a circular arrangement can be solved by considering two cases: either the first house is robbed or the last house is robbed. We can calculate the maximum amount that can be robbed for each case and take the maximum of the two. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/04-house-robber-2.md) |
| [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/) | To find the longest palindromic substring, we can consider each character in the string as the center of a potential palindrome and expand outwards from that center. We need to consider both odd-length and even-length palindromes. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/05-longest-palindromic-substring.md) |
| [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/description/) | To count the number of palindromic substrings, we can consider each character in the string as the center of a potential palindrome and expand outwards from that center. We need to consider both odd-length and even-length palindromes. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/06-palindromic-substrings.md) |
| [Decode Ways](https://leetcode.com/problems/decode-ways/description/) | The intuition behind the solution is that at each position in the string, we have two options: either decode a single digit or decode two digits (if possible). We need to consider all possible combinations of decoding and count the total number of ways. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/07-decode-ways.md) |
| [Coin Change](https://leetcode.com/problems/coin-change/description/) | The intuition behind the solution is that for each amount, we can choose any coin denomination and recursively solve the subproblem for the remaining amount. We need to consider all possible coin denominations and find the minimum number of coins needed. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/08-coin-change.md) |
| [Maximum Product SubArray](https://leetcode.com/problems/maximum-product-subarray/) | The intuition behind the solution is to keep track of both the maximum product and the minimum product encountered so far. This is because the minimum product can become the maximum product if multiplied by a negative number. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/09-maximum-product-subarray.md) |
| [Word break](https://leetcode.com/problems/word-break/) | The intuition behind the solution is to determine if the given string can be segmented into a space-separated sequence of one or more dictionary words. We can solve this problem by considering subproblems and using the results of smaller subproblems to solve larger ones.
 | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/10-word-break.md) |
| [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/description/) | The intuition behind the solution is to build the LIS by considering each element as a potential candidate for the LIS ending at that element. We can solve this problem by breaking it down into smaller subproblems and using the results of those subproblems to solve the larger problem. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/11-longest-increasing-subsequence.md) |
| [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/) | The intuition behind the solution is to find a subset of the given set whose sum is equal to half of the total sum of all the integers. If such a subset exists, then the remaining elements will form the other subset with an equal sum, resulting in a valid partition. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/1-D-DP/12-partition-equal-subset-sum.md) |



# 2-D DP
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Unique Paths](https://leetcode.com/problems/unique-paths/) | The intuition behind the solution is that the number of unique paths to reach any cell in the grid is the sum of the number of unique paths from the cell above it and the cell to its left. We can build a 2D array to store the number of unique paths for each cell and fill it in a bottom-up manner. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/01-unique-paths.md) |
| [Longest Increasing Subsequence](https://leetcode.com/problems/longest-common-subsequence/description/) | The intuition behind the solution is to build a 2D DP table where each cell represents the length of the LCS between the prefixes of the two strings up to the corresponding indices. We can fill the DP table in a bottom-up manner by considering the characters of both strings and making decisions based on whether they match or not. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/02-longest-common-subsequence.md) |
| [Best Time to Buy and Sell Stocks](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/) | The intuition behind the solution is to consider two states at each step: either the person is holding a stock or not holding a stock. We can make decisions based on these states and the current price, while also considering the cooldown constraint. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/03-best-time-to-buy-sell-stocks-with-cooldown.md) |
| [Coin Change](https://leetcode.com/problems/coin-change-ii/description/) | The intuition behind the solution is to consider each coin denomination and determine the number of ways to make up the remaining amount using the available coins. We can solve this problem by breaking it down into smaller subproblems and using the results of those subproblems to solve the larger problem. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/04-coin-change-2.md) |
| [Target Sum](https://leetcode.com/problems/target-sum/description/) | The intuition behind the solution is to consider the problem as a subset sum problem. We can partition the array into two subsets, one with positive integers and the other with negative integers, such that the sum of the positive subset minus the sum of the negative subset equals the target sum. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/05-target-sum.md) |
| [Interleaving Strings](https://leetcode.com/problems/interleaving-string/description/) | The intuition behind the solution is to consider the characters of s1 and s2 one by one and check if they match the characters of s3 in a valid interleaving order. We can solve this problem by breaking it down into smaller subproblems and using the results of those subproblems to solve the larger problem. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/06-interleaving-strings.md) |
| [Edit Distance](https://leetcode.com/problems/edit-distance/description/) | The intuition behind the solution is to consider the characters of both strings one by one and make decisions based on whether they match or not. We can solve this problem by breaking it down into smaller subproblems and using the results of those subproblems to solve the larger problem. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/07-edit-distance.md) |
| [Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) | The problem of finding the longest increasing path in a matrix can be solved using dynamic programming and depth-first search (DFS). The intuition behind the solution is to explore all possible paths starting from each cell in the matrix and keep track of the longest increasing path found so far. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/08-longest-increasing-path-in-a-matrix.md) |
| [Distinct Subsequence](https://leetcode.com/problems/distinct-subsequences/description/) | The intuition behind the solution is to consider each character of s and t one by one and make decisions based on whether they match or not. We can solve this problem by breaking it down into smaller subproblems and using the results of those subproblems to solve the larger problem. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/09-distinct-subsequences.md) |
| [Burst Ballons](https://leetcode.com/problems/burst-balloons/) | The intuition behind the solution is to consider the order in which the balloons are burst. We can divide the problem into smaller subproblems by considering the last balloon to be burst in each subproblem and recursively solve for the left and right subarrays. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/10-burst-ballons.md) |
| [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/description/) | The intuition behind the solution is to consider each character of the string and the pattern one by one and make decisions based on whether they match or not. We can solve this problem by breaking it down into smaller subproblems and using the results of those subproblems to solve the larger problem. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/2-D-DP/11-regular-expression-matching.md) |

### Trees
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |

### Trees
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |

### Trees
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |
| Row 3, Cell 1 | Row 3, Cell 2 | Row 3, Cell 3 |

# Bit Manipulation
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Single Number](https://leetcode.com/problems/single-number/) | The intuition is to use the XOR operation, which has the following properties: XORing a number with itself results in 0. XORing a number with 0 results in the number itself. XORing is associative and commutative. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Bit-Manipulation/01-single-number.md) |
| [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/) | The intuitive approach is to perform a bitwise AND operation between the number and its predecessor, which will effectively turn off the rightmost '1' bit in each iteration. By counting the number of iterations required to reduce the number to zero, we can determine the count of '1' bits. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Bit-Manipulation/02-number-of-1-bits.md) |
| [Counting Bits](https://leetcode.com/problems/counting-bits/description/) | To solve this problem, we need to count the number of '1' bits in the binary representation of each number from 0 to n. The intuitive approach is to use the built-in `Integer.bitCount()` method in Java, which returns the number of one-bits in the two's complement binary representation of an integer. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Bit-Manipulation/03-counting-bits.md) |
| [Reverse Bits](https://leetcode.com/problems/reverse-bits/) | To reverse the bits of a given 32-bit unsigned integer, we can iterate over each bit from the least significant bit to the most significant bit. In each iteration, we extract the last bit of the input number, add it to the result, and then shift the input number to the right by 1 to process the next bit.
 | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Bit-Manipulation/04-reverse-bits.md) |
| [Missing Number](https://leetcode.com/problems/missing-number/) | To find the missing number in the given array, we can utilize the fact that the array contains all numbers from 0 to n except for one missing number. By calculating the expected sum of all numbers from 0 to n and subtracting the actual sum of the numbers in the array, we can determine the missing number. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Bit-Manipulation/05-missing-number.md) |
| [Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/) | To calculate the sum of two integers without using the '+' operator, we can utilize bitwise operations. The key idea is to use the XOR operation to calculate the sum without considering the carry, and then use the AND operation to calculate the carry. We repeat this process until there is no carry left. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Bit-Manipulation/06-sum-of-two-numbers.md) |
| [Reverse Integer](https://leetcode.com/problems/reverse-integer/description/) | To reverse an integer, we can repeatedly extract the last digit of the number and append it to the reversed result. We need to handle the case of integer overflow by checking if the reversed result exceeds the range of a 32-bit signed integer. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Bit-Manipulation/07-reverse-integer.md) |