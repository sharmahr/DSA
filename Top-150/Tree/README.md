# Trees
| Problem | Notes | Solution |
|:-------------|:--------------:|-------------:|
| [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/description/) | Perform a level-order traversal of the tree using a queue and swap the left and right child of each node as we visit it. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/01-invert-binary-tree.md) |
| [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | The maximum depth of a tree is the maximum depth of its left subtree or its right subtree, plus one (to account for the root node). We can recursively traverse the tree, calculate the maximum depth of the left and right subtrees, and return the maximum of the two depths plus one. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/02-maximum-depth-of-binary-tree.md) |
| [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/description/) | To find the diameter of a binary tree, consider three cases: the diameter passing through the root (sum of left and right subtree heights), or the diameter being entirely within the left or right subtree. Use recursion to calculate the maximum diameter among these cases. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/03-diameter-of-binary-tree.md) |
| [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/description/) | Calculate the heights of the left and right subtrees at each node and check if their difference is within the allowed range. If at any point the difference exceeds 1, the tree is not balanced. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/04-balanced-binary-tree.md) |
| [Same Tree](https://leetcode.com/problems/same-tree/description/) | Recursively compare the nodes and their left and right subtrees. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/05-same-tree.md) |
| [Subtree of another Tree](https://leetcode.com/problems/subtree-of-another-tree/description/) | We can recursively compare each node of the main tree with the root of the subtree. If we find a node in the main tree that is the same as the root of the subtree, we can then compare the entire subtree starting from that node. If any such comparison returns true, then the subtree exists within the main tree. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/06-subtree-of-another-tree.md) |
| [Lowest Common Ancestor of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/) | The LCA is the node where the two nodes p and q diverge in the tree. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/07-lowest-common-ancestor-of-bst.md ) |
| [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/) | Process the nodes level by level, starting from the root. At each level, we enqueue the nodes from left to right and process them in the order they were enqueued. This ensures that we visit the nodes in level order. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/08-binary-tree-level-order-traversal.md) |
| [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/description/) | To find the right side view of a binary tree, we can perform a level order traversal (breadth-first search) and keep track of the rightmost node at each level. The rightmost node at each level will be the one visible from the right side. We can use a queue to perform the level order traversal and add the last node at each level to the result list. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/09-binary-tree-right-side-view.md) |
| [Count Of Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/) | To count the number of good nodes in a binary tree, we can perform a depth-first search (DFS) traversal and keep track of the maximum value encountered so far along each path. If the current node's value is greater than or equal to the maximum value seen so far, it is considered a good node. We can recursively traverse the tree and update the maximum value at each step. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/10-count-good-nodes-in-binary-tree.md) |
| [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/description/) | Keep track of the valid range for each node based on its ancestors. The valid range for a node is determined by the minimum and maximum values allowed for it to satisfy the BST property. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/11-validate-binary-search-tree.md) |
| [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/) | By performing an in-order traversal and storing the elements in a list, we can easily retrieve the kth smallest element by accessing the element at index k-1 in the list. | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/12-kth-smallest-element-in-bst.md) |
| [Construct Binary Tree from Inorder and Preorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/) | Create a map of the using the inorder array <val, index>, and then build tree recursively from the preorder by passing the start and end.| [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/13-construct-binary-tree-from-inorder-and-preorder-traversal.md) |
| [Maximum Path Sum in a Binary Tree](https://leetcode.com/problems/binary-tree-maximum-path-sum/) | Row 3, Cell 2 | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/14-binary-tree-maximum-path-sum.md) |
| [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/) | Use any of the traversals --> preorder, postorder ( along with a delimiter) or level order traversal | [Solution](https://github.com/sharmahr/DSA/blob/main/Top-150/Tree/15-serialize-deserialize-binary-tree.md) |